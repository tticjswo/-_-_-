# 세포 메트릭스 게임 구현

리눅스 프로그래밍을 통한 C 게임 구현


게임 진행 규칙
- (m x n) 크기의 2차원 매트릭스를 입력으로 받는다. 
- 입력받은 2차원 매트릭스의 한 칸은 하나의 세포라고 가정한다.
- 하나의 세포에 이웃하는 8칸은 이웃 세포라고 가정한다. 
- 세포 칸에 값 1이 들어있으면 살아있는 세포, 0이 들어있으면 죽은 세포라고 가정한다. (단, 세포 칸의 값은 0과 1 이외의 값은 갖지 않는다) 
- 가장자리 세포들의 경우 매트릭스 밖의 이웃 세포는 모두 0이라고 가정한다. 
- 임의의 값으로 설정된 “input.matrix” 파일로 입력되는 2차원 매트릭스를 0세대라 한 후, 각각의 모든
세포에 대해 아래의 규칙을 적용한 후 나오는 결과를 다음 세대라고 한다. (예: 0세대 다음은 1세대, 4세대 다음은 5세대)

1. 해당 세포가 살아있을 때, 살아있는 이웃 세포의 수가 2개 이하 혹은 7개 이상인 경우 해당 세포는 다음 세대에 죽는다. 
2. 해당 세포가 살아있을 때, 살아있는 이웃 세포의 수가 3개 ~ 6개인 경우 해당 세포는 다음 세대에 살아서 유지된다.
3. 해당 세포가 죽어있을 때, 살아있는 이웃 세포의 수가 4개인 경우 해당 세포는 다음 세대에 살아난다. 
4. 해당 세포가 죽어있을 때, 살아있는 이웃 세포의 수가 4개를 제외한 나머지 경우들에는 해당 세포는 다음 세대에 여전히 죽어있는 상태가 유지된다.

# 완료 후 아쉬운 점.

멀티 스레드를 활용한 병렬처리를 구현하였지만 수행 시간이 납득 가지 않는다. 프로세서의 경우 수행시간의 감소를 뚜렷히 파악할 수 있는데 멀티 스레드에서는 순차처리와 같거나 오히
려 순차처리보다 느린 경우도 종종 나왔다. 각 컴퓨터 환경이나 다른 요소들이 작용한 것도 있겠지만 왜 이렇게 나오는 것인지 정확히 모르겠다. 
여러 곳에서 알아본 결과 스레드가 루프 문에서 굉장히 느리다 라던지 함수 실행 시간 측정 함수가 잘못 됬다던 지라는 이유라고 파악하였다... 
내가 생각했을 때의 수행시간이 길게 걸리는 이유는 pthread_join 때문이 아닐 까 싶다. 
main thread는 모든 자식 thread를 기다리게 해야 하는 데 반복문 안에서 이를 진행하였고, 첫 번째 스레드의 종료가 되었을 때 다음 스레드의 종료를 확인한다. 
이는 모든 자식 스레드 중에서 실행 시간이 제일 빨라서 종료된 스레드 혹인 주어진 데이터 양이 적어 먼저 종료된 스레드 등을 파악하는 게 아니라 pthread_create()를 한 순서대로 끝났는지를 확인하는 것이 되어 순차처리와 전체 시간이 비슷해 진 게 아닌가 싶다. 함수 수행시간 자체는 적은데 기다리는 시간이 모두 포함되어 버린 듯 하다. 
